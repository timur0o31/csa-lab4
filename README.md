# Альметов Тимур Айдарович, P3207
- Вариант:  forth | stack | harv | hw | tick | binary | trap | port | cstr | prob2 | superscalar
## Содержание
1. [Язык программирования](#язык-программирования)
2. [Организация памяти](#организация-памяти)
3. [Система команд](#система-команд)
4. [Транслятор](#транслятор)
5. [Модель процессора](#модель-процессора)
6. [Тестирование](#тестирование)

## Язык программирования
Описание синтаксиса языка в стиле БНФ:
```ebnf
<programm> ::= <instruction_line>*
<instruction_line> ::= <label>
                     | <instruction> "\n"
                     | "\n"
                     | <const_declaration> "\n"
<label> ::= <label_name> ":"
<label_name> ::= [a-zA-Z_][a-zA-Z0-9_]*
<const_declaration> ::= "const" <label_name> <number> 
<instruction> ::= <op0>
                | <op1> " " <literal>
<op0> ::= "nop"
       | "@"
       | "!"
       | "+"
       | "+2"       
       | "-"
       | "*"
       | "div"
       | "inc"
       | "dec"
       | "drop"
       | "dup"
       | "and"
       | "swap"
       | "xor"
       | "or"
       | "not"
       | "jump"
       | "call"
       | "jz"
       | "jn"
       | "ret"
       | "in"
       | "out"
       | "halt"

<op1> ::= "lit"
<literal> ::= <number>
<number> ::= "-"? <digit>+  
<digit> ::= [0-9]

<comment> ::= ";" <characters>
<characters> ::= .*                      
                  

```
### Семантика 
Код выполняется последовательно одна инструкция за другой.

Пример программы:
```ebnf
const res 0x1

fact:
	dup
	lit loop_end 
	jn 
	dup
	lit loop_end
	jz 
fact_loop:
	dup
	lit res
	@
	*
	lit res
	!
	dec
	lit loop_end
	jz
	lit fact_loop
	jump
loop_end:
	ret

start:
	lit 5
	lit fact 
	call
	halt

```
Язык поддерживает всего 2 типов данных:
1. Целые числа.
2. Строки.
Числа целые 32-битные.
Отдельные символы строки имеют тип целого числа.
Поддерживаются строковые литералы произвольной длины. В конце строки ставится символ-ноль \0, в соответствии с вариантом.
Область видимости переменных - глобальные.
Стратегия вычислений строгая, аппликативный порядок. То есть все вычисления происходят в том порядке, в каком они даны в программе.

## Организация памяти
- Система построена по Гарвардской архитектуре, то есть есть разделение команд и данных.
1. Память данных: 32 бит. 
2. Память команд: 32 бит.
   Обе памяти работают в линейном, адресном пространстве.
- Операнды - знаковые 24-разрядные числа, так как 8 бит используется для кода операции.
- Литералы - это знаковые 32-битные значения, но в машинной инструкции lit они могут быть закодированы только в пределах 24 бит. Для представления полных 32-битных литералов используется чтение из памяти.
- Адресация прямая абсолютная. Только прямая загрузка литерала в ячейку памяти (const/на вершину стека (LIT)). Косвенная адресация достижима с использованием стека.
- Память данных разделена на массивы - разделение определяет пользователь, именуя каждый массив лейблом;
- Массив может состоять из строк, чисел и свободного места. Все данные в массивах и все массивы идут последовательно.
```       Registers
+------------------------------+
| TOS                          |
+------------------------------+
| Stack Registers              |
|    SP                        |
|    RP 		       |
|    RSP                       |
+------------------------------+
| PC, A                        |
+------------------------------+

       Program memory
+------------------------------+ 
| 0x00 : jump n                |
|   ...                        | 
|  n : _start: instruction     |
|   ...                        |
+------------------------------+

          Data memory
+------------------------------+
| 00  : array 1                |
|    ...                       |
|  n  : array 2                |
|    ...                       |                                   
+------------------------------+
```
### Организация стека:
- Имеются стек данных и стек возврата.
- Основной стек (stack) реализован как структура данных deque с дополнительным регистрами S1, S2 (TOS), хранящими первые два значения вершины стека.
- Стек 32-разрядный и позволяет полностью помещать один операнд одной ячейки памяти. 
### Регистры
Используются следующие регистры:
- A0 - вспомогательный регистр
- A1 - вспомогательный регистр
- PC - регистр команд
- RP - указатель стека возврата
- SP - указатель стека данных
- RSP - 
## Система команд:
### Особенности процессора:
- Машинное слово - 32 битное число.
- Обработка данных осуществляется в стеке. Данные попадают в стек из памяти, либо из устройств ввода/вывода.
- Доступ к памяти осуществляется через указатель на вершине стека. Установить адрес можно через lit.
- Устройство ввода-вывода: port-mapped
- Поток управления:
  - Инкрементирование PC;
  - Условный/безусловный переход;
  - 
### Набор инструкций:
- `nop` - нет операции.
- `lit <literal>` - положить значение на вершину стека.
- `@` - загрузить из памяти значение по адресу с вершины стека.
- `!` - положить второе значение с вершины стека в память по указанному адресу, который лежит на вершине стека. 
- `+` - положить на стек результат операции сложения двух верхних значений с вершины стека.
- `-` - положить на стек результат операции вычитания двух верхних значений с вершины стека.
- `*` - положить на стек результат операции умножения двух верхних значений с вершины стека.
- `+2` - положить на стек результат операции сложения двойной точности двух верхних значений с вершины стека,
- `div` - положить на стек результат операции деления двух верхних значений с вершины стека.
- `inc` - положить на стек результат операции инкремнтирования на 1 значения вершины стека.
- `dec` - положить на стек результат операции декрементирования на 1 значения вершины стека.
- `drop` - удалить элемент из стека.
- `dup` - дублировать элемент на стеке.
- `and` - положить на стек результат операции логического "и" двух верхних значений вершины стека.
- `swap` - 
- `or` - положить на стек результат операции логического "или" двух верхних значений вершины стека.
- `xor` - положить на стек результат операции исключающего "или" двух верхних значений вершины стека.
- `not` - положить на стек результат операции логического "не" значения вершины стека.
- `jump` - безусловный переход 
- `call` - вызов подпрограммы
- `jz` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека равно 0
- `jn` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека меньше 0
- `ret` - возврат
- `in` - 
- `out` -
- `halt` - останов
Бинарное представление
┌─────┬───────────────────────────────┬─────────────────────────────────┐
│     |                                                                     │
├─────┼───────────────────────────────┼──────────────────────────────────┤
│  op0│                                │
├─────┼───────────────────────────────┴──────────────────────────────────┤
│  op1│                    │
───────────────────────────────────────────────────────────────────────┤
## Транслятор
Реализация транслятора ...

## Модель процессора
Реализация модели процессора: ...
### Ввод - вывод

### DataPath

### Control-Unit

### Прерывания
## Тестирование
