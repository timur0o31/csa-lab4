# Альметов Тимур Айдарович, P3207
- Вариант:  forth | stack | harv | hw | tick | binary | trap | port | cstr | prob2 | superscalar
## Содержание
1. [Язык программирования](#язык-программирования)
2. [Организация памяти](#организация-памяти)
3. [Система команд](#система-команд)
4. [Транслятор](#транслятор)
5. [Модель процессора](#модель-процессора)
6. [Тестирование](#тестирование)

## Язык программирования
Описание синтаксиса языка в стиле БНФ:
```ebnf
<programm> ::= <instruction_line>*
<instruction_line> ::= <label>
                     | <instruction>+ "\n"
                     | "\n"
                     | <var_declaration> "\n"
                     | <vect_decl> "\n"
<label> ::= <label_name> ":"
<label_name> ::= [a-zA-Z_][a-zA-Z0-9_]*
<var_decl> ::= "var" <label_name> <number> 
<instruction> ::= <op0>
                | <op1> " " <literal>
<op0> ::= "nop"
       | "@"
       | "!"
       | "+"
       | "+2"       
       | "-"
       | "*"
       | "/"
       | "inc"
       | "dec"
       | "drop"
       | "dup"
       | "and"
       | "swap"
       | "xor"
       | "or"
       | "not"
       | "jump"
       | "call"
       | "jz"
       | "jn"
       | "ret"
       | "in"
       | "out"
       | "halt"
       | "int"
       | "iret"
<op1> ::= "lit"

<literal> ::= <number>
<number> ::= "-"? <digit>+  
<digit> ::= [0-9]

<vect_decl> ::= "vector" <number> <label_name>

<comment> ::= ";" <characters>
<characters> ::= .*                                        

```
### Семантика 
Код выполняется последовательно одна инструкция за другой.

Пример программы:
```ebnf
var res 0x1

fact:
	dup
	lit loop_end 
	jn 
	dup
	lit loop_end
	jz 
fact_loop:
	dup
	lit res
	@
	*
	lit res
	!
	dec
	lit loop_end
	jz
	lit fact_loop
	jump
loop_end:
	ret

start:
	lit 5
	lit fact 
	call
	halt

```
Язык поддерживает всего 2 типов данных:
1. Целые числа.
2. Строки.
Числа целые 32-битные.
Отдельные символы строки имеют тип целого числа.
Поддерживаются строковые литералы произвольной длины. В конце строки ставится символ-ноль \0, в соответствии с вариантом.
Область видимости переменных - глобальные.
Стратегия вычислений строгая, аппликативный порядок. То есть все вычисления происходят в том порядке, в каком они даны в программе.
	
## Организация памяти
- Система построена по Гарвардской архитектуре, то есть есть разделение команд и данных.
1. Память данных: 32 бит. 
2. Память команд: 32 бит.
   Обе памяти работают в линейном, адресном пространстве.
- Операнды - знаковые 27-разрядные числа, так как 5 бит используется для кода операции.
- Литералы - это знаковые 32-битные значения, но в машинной инструкции lit они могут быть закодированы только в пределах 27 бит. Для представления полных 32-битных литералов используется чтение из памяти.
- Адресация прямая абсолютная. Только прямая загрузка литерала в ячейку памяти (const/на вершину стека (LIT)). Косвенная адресация достижима с использованием стека.
- Память данных разделена на массивы - разделение определяет пользователь, именуя каждый массив лейблом;
- Массив может состоять из строк, чисел и свободного места. Все данные в массивах и все массивы идут последовательно.
```       Registers
+------------------------------+
| TOS                          |
+------------------------------+
| Stack Registers              |
|    SP                        |
|    RP 		       |
|    RSP                       |
+------------------------------+
| PC, A                        |
+------------------------------+

       Program memory
+------------------------------+ 
| 0x00 : jump n                |
|   ...                        | 
|  n : _start: instruction     |
|   ...                        |
+------------------------------+

          Data memory
+------------------------------+
| 00  : array 1                |
|    ...                       |
|  n  : array 2                |
|    ...                       |                                   
+------------------------------+
```
### Организация стека:
- Имеются стек данных и стек возврата.
- Основной стек (stack) реализован как структура данных deque с дополнительным регистрами S1, S2 (TOS), хранящими первые два значения вершины стека.
- Стек 32-разрядный и позволяет полностью помещать один операнд одной ячейки памяти. 
### Регистры
Используются следующие регистры:
- A0 - вспомогательный регистр
- A1 - вспомогательный регистр
- PC - регистр команд
- RP - указатель стека возврата
- SP - указатель стека данных
- RSP - 
## Система команд:
### Особенности процессора:
- Машинное слово - 32 битное число.
- Обработка данных осуществляется в стеке. Данные попадают в стек из памяти, либо из устройств ввода/вывода.
- Доступ к памяти осуществляется через указатель на вершине стека. Установить адрес можно через lit.
- Устройство ввода-вывода: port-mapped
- Поток управления:
  - Инкрементирование PC;
  - Условный/безусловный переход;
  - Обработка прерываний с возвратом через return stack
### Набор инструкций:
| №  | Мнемоника  | Opcode (bin) | Opcode (hex) | Число тактов| 
|----|------------|--------------|---------------|---------------|
| 0  | `nop`      | `00000`      | `0x00`        |	 1	 |
| 1  | `lit`      | `00001`      | `0x01`        |	 1       |
| 2  | `@`        | `00010`      | `0x02`        |	 2       |
| 3  | `!`        | `00011`      | `0x03`        |	 2       |
| 4  | `+`        | `00100`      | `0x04`        |	 1       |
| 5  | `-`        | `00101`      | `0x05`        |	 1       |
| 6  | `*`        | `00110`      | `0x06`        |	 1       |
| 7  | `+2`       | `00111`      | `0x07`        |	         |
| 8  | `div`      | `01000`      | `0x08`        |	 1       |
| 9  | `inc`      | `01001`      | `0x09`        |       1       |
| 10 | `dec`      | `01010`      | `0x0A`        |       1       |
| 11 | `drop`     | `01011`      | `0x0B`        |       1       |
| 12 | `dup`      | `01100`      | `0x0C`        |	 1       |
| 13 | `and`      | `01101`      | `0x0D`        |       1       |
| 14 | `or`       | `01110`      | `0x0E`        |       1       |
| 15 | `xor`      | `01111`      | `0x0F`        |	 1       |
| 16 | `not`      | `10000`      | `0x10`        |	 1       |
| 17 | `swap`     | `10001`      | `0x11`        |	 2       |
| 18 | `jump`     | `10010`      | `0x12`        |       1       |
| 19 | `call`     | `10011`      | `0x13`        |       1       |
| 20 | `jz`       | `10100`      | `0x14`        |       1       |
| 21 | `jn`       | `10101`      | `0x15`        |       1       |
| 22 | `ret`      | `10110`      | `0x16`        |       1       |
| 23 | `in`       | `10111`      | `0x17`        |	 1       |
| 24 | `out`      | `11000`      | `0x18`        |       1       |
| 25 | `rint`     | `11001`      | `0x19`        |       2       |
| 26 | `halt`     | `11111`      | `0x1F`        |       1       |

Описание: 
- `nop` - нет операции.
- `lit <literal>` - положить значение на вершину стека.
- `@` - загрузить из памяти значение по адресу с вершины стека.
- `!` - положить второе значение с вершины стека в память по указанному адресу, который лежит на вершине стека. 
- `+` - положить на стек результат операции сложения двух верхних значений с вершины стека.
- `-` - положить на стек результат операции вычитания двух верхних значений с вершины стека.
- `*` - положить на стек результат операции умножения двух верхних значений с вершины стека.
- `+2` - положить на стек результат операции сложения двойной точности двух верхних значений с вершины стека,
- `div` - положить на стек результат операции деления двух верхних значений с вершины стека.
- `inc` - положить на стек результат операции инкремнтирования на 1 значения вершины стека.
- `dec` - положить на стек результат операции декрементирования на 1 значения вершины стека.
- `drop` - удалить элемент из стека.
- `dup` - дублировать элемент на стеке.
- `and` - положить на стек результат операции логического "и" двух верхних значений вершины стека.
- `swap` - 
- `or` - положить на стек результат операции логического "или" двух верхних значений вершины стека.
- `xor` - положить на стек результат операции исключающего "или" двух верхних значений вершины стека.
- `not` - положить на стек результат операции логического "не" значения вершины стека.
- `jump` - безусловный переход 
- `call` - вызов подпрограммы
- `jz` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека равно 0
- `jn` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека меньше 0
- `ret` - возврат 
- `in` - 
- `out` -
- `rint` - 
- `halt` - останов
- 
### Прерывания
## Транслятор
Реализация транслятора ...

## Модель процессора
Реализация модели процессора: ...
### Ввод - вывод

### DataPath

### Control-Unit

## Тестирование
