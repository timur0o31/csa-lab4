# Альметов Тимур Айдарович, P3207
- Вариант:  forth | stack | harv | hw | tick | binary | trap | port | cstr | prob2 | superscalar
## Содержание
1. [Язык программирования](#язык-программирования)
2. [Организация памяти](#организация-памяти)
3. [Система команд](#система-команд)
4. [Транслятор](#транслятор)
5. [Модель процессора](#модель-процессора)
6. [Тестирование](#тестирование)

## Язык программирования
Описание синтаксиса языка в стиле БНФ:
```ebnf
<program> ::= <statement>+ 

<statement> ::= <procedure_def>
                        | <if_statement>
                        | <loop_statement>
                        | <line>
<line> ::= <word>+ "\n"
         | "\n"
         | <var_declaration>
         | <string-declaration>
         | <array-declaration> 

<var_declaration> ::= "var" <name> <number>?

<string-literal-declaration> ::= 'str' name literal

<array-declaration> ::= 'array' name memory-block-size

<word> ::= <control_instr>
        | <io_instr>
        | <instr>
        | <comment>

<procedure_def> ::= ":" <name> <word>* ";"

<name> ::= [a-zA-Z_][a-zA-Z0-9_]*

if-statement ::= 'if' statement-body ('then' | ('else' statement-body 'then'))

loop-statement ::= 'begin' statement-body 'exit'? 'again'

<io_instr> ::= "in" | "out"
<instr> ::= "@" | "!" | "+" | "-" | "*" | "/" | "and" | "or" | "xor" | "not" |
		"dup" | "drop" | "swap" | "inc" | "dec"
<control_instr> ::= "halt" | "eint" | "dint" | ";" | "iret"

<number> ::= "-"? <digit>+
<digit> ::= [0-9]

<comment> ::= "\" <characters>
<characters> ::= .*

```
### Семантика 
Код выполняется последовательно одна инструкция за другой.

Пример программы:
```

```
Язык поддерживает всего 2 типов данных:
1. Целые числа.
2. Строки.
Числа целые 32-битные.
Отдельные символы строки имеют тип целого числа.
Поддерживаются строковые литералы произвольной длины. В конце строки ставится символ-ноль \0, в соответствии с вариантом.
Область видимости переменных - глобальные.
Стратегия вычислений строгая, аппликативный порядок. То есть все вычисления происходят в том порядке, в каком они даны в программе.
	
## Организация памяти
- Система построена по Гарвардской архитектуре, то есть есть разделение команд и данных.
1. Память данных: 32 бит. 
2. Память команд: 32 бит.
   Обе памяти работают в линейном, адресном пространстве.
- Операнды - знаковые 27-разрядные числа, так как 5 бит используется для кода операции.
- Литералы - это знаковые 32-битные значения, но в машинной инструкции lit они могут быть закодированы только в пределах 27 бит. Для представления полных 32-битных литералов используется чтение из памяти.
- Адресация прямая абсолютная. Только прямая загрузка литерала в ячейку памяти (const/на вершину стека). Косвенная адресация достижима с использованием стека.
- Память данных разделена на массивы - разделение определяет пользователь, именуя каждый массив названием;
- Массив может состоять из символов, чисел и свободного места. Все данные в массивах и все массивы идут последовательно.
```       Registers
+------------------------------+
| TOS                          |
+------------------------------+
| Stack Registers              |
|    SP                        |
|    AR 		       |
|    SCP		       |
| Call Stack                   |
+------------------------------+
| PC,                          |
+------------------------------+

       Program memory
+------------------------------+ 
| 0x00 : jump n                |
|   ...                        | 
|  n : _start: instruction     |
|   ...                        |
+------------------------------+

          Data memory
+------------------------------+
| 00  : array 1                |
|    ...                       |
|  n  : array 2                |
|    ...                       |                                   
+------------------------------+
```
### Организация стека:
- Имеются стек данных и стек возврата.
- Основной стек (stack) реализован как структура данных deque с дополнительным регистром TOS, хранящим первое значение вершины стека.
- Стек 32-разрядный и позволяет полностью помещать один операнд одной ячейки памяти. 
### Регистры
Используются следующие регистры:
- PC - регистр команд
- SCP - указатель стека возврата
- SP - указатель стека данных
- AR - указатель адреса памяти
- 
## Система команд:
### Особенности процессора:
- Машинное слово - 32 битное число.
- Обработка данных осуществляется в стеке. Данные попадают в стек из памяти, либо из устройств ввода/вывода.
- Доступ к памяти осуществляется через указатель на вершине стека. Установить адрес можно через прямую загрузку.
- Устройство ввода-вывода: port-mapped
- Поток управления:
  - Инкрементирование PC;
  - Условный/безусловный переход;
  - Обработка прерываний с возвратом через return_addr
  - 
### Набор инструкций:
| №  | Мнемоника  | Opcode (bin) | Opcode (hex) | Число тактов| 
|----|------------|--------------|---------------|---------------|
| 0  | `nop`      | `00000`      | `0x00`        |	 1	 |
| 1  | `lit`      | `00001`      | `0x01`        |	 1       |
| 2  | `@`        | `00010`      | `0x02`        |	 2       |
| 3  | `!`        | `00011`      | `0x03`        |	 2       |
| 4  | `+`        | `00100`      | `0x04`        |	 1       |
| 5  | `-`        | `00101`      | `0x05`        |	 1       |
| 6  | `*`        | `00110`      | `0x06`        |	 1       |
| 7  | `mulh`       | `00111`      | `0x07`      |	 1       |
| 8  | `div`      | `01000`      | `0x08`        |	 1       |
| 9  | `inc`      | `01001`      | `0x09`        |       1       |
| 10 | `dec`      | `01010`      | `0x0A`        |       1       |
| 11 | `drop`     | `01011`      | `0x0B`        |       1       |
| 12 | `dup`      | `01100`      | `0x0C`        |	 1       |
| 13 | `and`      | `01101`      | `0x0D`        |       1       |
| 14 | `or`       | `01110`      | `0x0E`        |       1       |
| 15 | `xor`      | `01111`      | `0x0F`        |	 1       |
| 16 | `not`      | `10000`      | `0x10`        |	 1       |
| 17 | `swap`     | `10001`      | `0x11`        |	 2       |
| 18 | `jump`     | `10010`      | `0x12`        |       1       |
| 19 | `call`     | `10011`      | `0x13`        |       1       |
| 20 | `jz`       | `10100`      | `0x14`        |       2       |
| 21 | `jn`       | `10101`      | `0x15`        |       2       |
| 22 | `ret`      | `10110`      | `0x16`        |       1       |
| 23 | `in`       | `10111`      | `0x17`        |	 1       |
| 24 | `out`      | `11000`      | `0x18`        |       1       |
| 25 | `iret`     | `11001`      | `0x19`        |       2       |
| 26 | `halt`     | `11111`      | `0x1F`        |       1       |

Описание: 
- `nop` - нет операции.
- `lit <literal>` - положить значение на вершину стека.
- `@` - загрузить из памяти значение по адресу с вершины стека.
- `!` - положить второе значение с вершины стека в память по указанному адресу, который лежит на вершине стека. 
- `+` - положить на стек результат операции сложения двух верхних значений с вершины стека.
- `-` - положить на стек результат операции вычитания двух верхних значений с вершины стека.
- `*` - положить на стек результат операции умножения двух верхних значений с вершины стека.
- `mulh` - положить на стек результат операции умножения двух верхних значений с вершины стека
- `div` - положить на стек результат операции деления двух верхних значений с вершины стека.
- `inc` - положить на стек результат операции инкремнтирования на 1 значения вершины стека.
- `dec` - положить на стек результат операции декрементирования на 1 значения вершины стека.
- `drop` - удалить элемент из стека.
- `dup` - дублировать элемент на стеке.
- `and` - положить на стек результат операции логического "и" двух верхних значений вершины стека.
- `swap` - поменять местами два верхних значения
- `or` - положить на стек результат операции логического "или" двух верхних значений вершины стека.
- `xor` - положить на стек результат операции исключающего "или" двух верхних значений вершины стека.
- `not` - положить на стек результат операции логического "не" значения вершины стека.
- `jump` - безусловный переход 
- `call` - вызов подпрограммы
- `jz` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека равно 0
- `jn` - переход на адрес лежащий на вершине стека, если второе значение с вершины стека меньше 0
- `ret` - возврат 
- `in` - считать символ с устройства
- `out` - вывести символ на устройство
- `iret` - возврат в основной ход выполнения программы из прерывания
- `eint` - разрешение прерываний
- `dint` -  запрет прерываний 
- `halt` - останов
- 
### Прерывания
## Транслятор
Интерфейс командной строки: translator.py <input_file> <target_instructions_file> <target_data_file>
Реализация транслятора ...
Этапы трансляции:	
- Замена 
-
## Модель процессора
Интерфейс командной строки: machine.py <instructions_bin_file> <data_bin_file> <input_file>.
Реализация модели процессора: ...
Сигналы реализованы в виде м
Флаги
Control Unit
Прерывания
### Ввод - вывод

### DataPath

### Control-Unit

## Тестирование
